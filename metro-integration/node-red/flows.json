[
    {
        "id": "sparking-metro-flow",
        "type": "tab",
        "label": "SParking Metro Integration",
        "disabled": false,
        "info": "Metro AI Suite integration flows for slot occupancy logic and automation rules"
    },
    {
        "id": "mqtt-broker-config",
        "type": "mqtt-broker",
        "name": "SParking MQTT Broker",
        "broker": "mqtt",
        "port": "1883",
        "clientid": "nodered-sparking",
        "autoConnect": true,
        "usetls": false,
        "protocolVersion": "5",
        "keepalive": "60",
        "cleansession": true,
        "autoUnsubscribe": true,
        "birthTopic": "nodered/status",
        "birthQos": "0",
        "birthPayload": "online",
        "closeTopic": "nodered/status",
        "closeQos": "0",
        "closePayload": "offline",
        "willTopic": "nodered/status",
        "willQos": "0",
        "willPayload": "offline"
    },
    {
        "id": "detection-input",
        "type": "mqtt in",
        "z": "sparking-metro-flow",
        "name": "Metro Detections",
        "topic": "object_detection_#",
        "qos": "0",
        "datatype": "json",
        "broker": "mqtt-broker-config",
        "nl": false,
        "rap": false,
        "inputs": 0,
        "x": 120,
        "y": 100,
        "wires": [["parse-detection"]]
    },
    {
        "id": "parse-detection",
        "type": "function",
        "z": "sparking-metro-flow",
        "name": "Parse Metro Detection",
        "func": "// Parse Metro AI Suite detection format\nconst topic = msg.topic;\nconst payload = msg.payload;\n\n// Extract camera index from topic\nconst match = topic.match(/object_detection_(\\d+)/);\nif (!match) {\n    node.warn('Invalid topic format: ' + topic);\n    return null;\n}\n\nconst cameraIndex = match[1];\n\n// Get camera mapping from global context or flow context\nconst cameraMapping = flow.get('cameraMapping') || {};\nconst cameraId = cameraMapping[cameraIndex] || cameraIndex;\n\n// Extract objects from Metro format\nconst metadata = payload.metadata || {};\nconst objects = metadata.objects || [];\n\n// Filter for vehicles\nconst vehicleLabels = ['car', 'truck', 'bus', 'motorcycle', 'bicycle', 'suv', 'van'];\nconst vehicles = objects.filter(obj => {\n    const label = (obj.detection?.label || '').toLowerCase();\n    return vehicleLabels.includes(label);\n});\n\nif (vehicles.length === 0) {\n    return null;\n}\n\n// Create detection event\nmsg.payload = {\n    cameraId: cameraId,\n    cameraIndex: cameraIndex,\n    timestamp: new Date().toISOString(),\n    vehicleCount: vehicles.length,\n    detections: vehicles.map(v => ({\n        label: v.detection?.label,\n        confidence: v.detection?.confidence,\n        bbox: v.detection?.bounding_box,\n        attributes: v.attributes || {}\n    }))\n};\n\nmsg.cameraId = cameraId;\nmsg.vehicleCount = vehicles.length;\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 340,
        "y": 100,
        "wires": [["occupancy-tracker", "debug-detection"]]
    },
    {
        "id": "occupancy-tracker",
        "type": "function",
        "z": "sparking-metro-flow",
        "name": "Slot Occupancy Tracker",
        "func": "// Track slot occupancy based on detections\nconst cameraId = msg.cameraId;\nconst detections = msg.payload.detections;\n\n// Get slot configuration for this camera from context\nconst slotConfig = flow.get(`slots_${cameraId}`) || [];\nconst previousState = flow.get(`state_${cameraId}`) || {};\n\nif (slotConfig.length === 0) {\n    // No slots configured for this camera\n    return null;\n}\n\nconst events = [];\nconst newState = {};\n\n// Check each slot for occupancy\nslotConfig.forEach(slot => {\n    const slotBounds = slot.detectionBounds;\n    let occupied = false;\n    let matchedDetection = null;\n    \n    // Check if any detection overlaps with this slot\n    detections.forEach(det => {\n        if (!det.bbox) return;\n        \n        const bbox = det.bbox;\n        const detCenter = {\n            x: (bbox.x_min + bbox.x_max) / 2,\n            y: (bbox.y_min + bbox.y_max) / 2\n        };\n        \n        // Check if detection center is within slot bounds\n        if (detCenter.x >= slotBounds.x &&\n            detCenter.x <= slotBounds.x + slotBounds.width &&\n            detCenter.y >= slotBounds.y &&\n            detCenter.y <= slotBounds.y + slotBounds.height) {\n            occupied = true;\n            matchedDetection = det;\n        }\n    });\n    \n    newState[slot.id] = occupied;\n    \n    // Check for state change\n    const wasOccupied = previousState[slot.id] || false;\n    \n    if (occupied && !wasOccupied) {\n        // Slot became occupied\n        events.push({\n            slotId: slot.id,\n            cameraId: cameraId,\n            eventType: 'SLOT_OCCUPIED',\n            confidence: matchedDetection?.confidence || 0.5,\n            vehicleType: matchedDetection?.label?.toUpperCase() || 'UNKNOWN',\n            timestamp: new Date().toISOString()\n        });\n    } else if (!occupied && wasOccupied) {\n        // Slot became vacant\n        events.push({\n            slotId: slot.id,\n            cameraId: cameraId,\n            eventType: 'SLOT_VACATED',\n            timestamp: new Date().toISOString()\n        });\n    }\n});\n\n// Save new state\nflow.set(`state_${cameraId}`, newState);\n\nif (events.length === 0) {\n    return null;\n}\n\n// Return events as separate messages\nreturn events.map(event => ({\n    payload: event,\n    topic: 'sparking/slot/' + event.eventType.toLowerCase()\n}));",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "// Initialize camera-to-slot mappings\n// This can be loaded from the SParking API or configured manually\n\nflow.set('cameraMapping', {\n    // Map camera indices to UUIDs\n    // '1': 'camera-uuid-1',\n    // '2': 'camera-uuid-2'\n});\n\n// Slot configurations will be loaded dynamically\n// or can be set manually per camera\n// flow.set('slots_camera-uuid-1', [\n//     { id: 'slot-1', detectionBounds: { x: 0.1, y: 0.1, width: 0.2, height: 0.3 } }\n// ]);",
        "finalize": "",
        "libs": [],
        "x": 580,
        "y": 100,
        "wires": [["rate-limiter"]]
    },
    {
        "id": "rate-limiter",
        "type": "delay",
        "z": "sparking-metro-flow",
        "name": "Rate Limit",
        "pauseType": "rate",
        "timeout": "5",
        "timeoutUnits": "seconds",
        "rate": "10",
        "nbRateUnits": "1",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": false,
        "allowrate": false,
        "outputs": 1,
        "x": 770,
        "y": 100,
        "wires": [["publish-event", "http-forward"]]
    },
    {
        "id": "publish-event",
        "type": "mqtt out",
        "z": "sparking-metro-flow",
        "name": "Publish to SParking",
        "topic": "",
        "qos": "1",
        "retain": "false",
        "respTopic": "",
        "contentType": "application/json",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "mqtt-broker-config",
        "x": 970,
        "y": 80,
        "wires": []
    },
    {
        "id": "http-forward",
        "type": "http request",
        "z": "sparking-metro-flow",
        "name": "Forward to API",
        "method": "POST",
        "ret": "obj",
        "paytoqs": "ignore",
        "url": "http://app:3000/api/realtime/detection",
        "tls": "",
        "persist": true,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": true,
        "headers": [
            {
                "keyType": "other",
                "keyValue": "Content-Type",
                "valueType": "other",
                "valueValue": "application/json"
            },
            {
                "keyType": "other",
                "keyValue": "x-api-key",
                "valueType": "env",
                "valueValue": "DETECTION_API_KEY"
            }
        ],
        "x": 960,
        "y": 140,
        "wires": [["api-response"]]
    },
    {
        "id": "api-response",
        "type": "switch",
        "z": "sparking-metro-flow",
        "name": "Check Response",
        "property": "statusCode",
        "propertyType": "msg",
        "rules": [
            {
                "t": "btwn",
                "v": "200",
                "vt": "num",
                "v2": "299",
                "v2t": "num"
            },
            {
                "t": "else"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 2,
        "x": 1140,
        "y": 140,
        "wires": [["debug-success"], ["debug-error"]]
    },
    {
        "id": "debug-detection",
        "type": "debug",
        "z": "sparking-metro-flow",
        "name": "Detection Log",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": true,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "vehicleCount",
        "statusType": "msg",
        "x": 350,
        "y": 180,
        "wires": []
    },
    {
        "id": "debug-success",
        "type": "debug",
        "z": "sparking-metro-flow",
        "name": "API Success",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": true,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "statusCode",
        "statusType": "msg",
        "x": 1330,
        "y": 120,
        "wires": []
    },
    {
        "id": "debug-error",
        "type": "debug",
        "z": "sparking-metro-flow",
        "name": "API Error",
        "active": true,
        "tosidebar": true,
        "console": true,
        "tostatus": true,
        "complete": "true",
        "targetType": "full",
        "statusVal": "statusCode",
        "statusType": "msg",
        "x": 1320,
        "y": 160,
        "wires": []
    },
    {
        "id": "inject-config-loader",
        "type": "inject",
        "z": "sparking-metro-flow",
        "name": "Load Config on Start",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": "2",
        "topic": "",
        "payload": "{}",
        "payloadType": "json",
        "x": 160,
        "y": 300,
        "wires": [["fetch-camera-config"]]
    },
    {
        "id": "fetch-camera-config",
        "type": "http request",
        "z": "sparking-metro-flow",
        "name": "Fetch Cameras",
        "method": "GET",
        "ret": "obj",
        "paytoqs": "ignore",
        "url": "http://app:3000/api/cameras",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [
            {
                "keyType": "other",
                "keyValue": "x-api-key",
                "valueType": "env",
                "valueValue": "DETECTION_API_KEY"
            }
        ],
        "x": 380,
        "y": 300,
        "wires": [["store-camera-config"]]
    },
    {
        "id": "store-camera-config",
        "type": "function",
        "z": "sparking-metro-flow",
        "name": "Store Camera Config",
        "func": "// Store camera configuration in flow context\nconst cameras = msg.payload;\n\nif (!Array.isArray(cameras)) {\n    node.warn('Invalid camera response');\n    return null;\n}\n\n// Build camera mapping and slot configurations\nconst cameraMapping = {};\n\ncameras.forEach((camera, index) => {\n    // Map index to camera ID\n    cameraMapping[String(index + 1)] = camera.id;\n    \n    // Store slot configuration for each camera\n    if (camera.slots && camera.slots.length > 0) {\n        const slotConfig = camera.slots.map(slot => ({\n            id: slot.id,\n            detectionBounds: slot.detectionBounds || {\n                x: 0,\n                y: 0,\n                width: 1,\n                height: 1\n            }\n        }));\n        flow.set(`slots_${camera.id}`, slotConfig);\n    }\n});\n\nflow.set('cameraMapping', cameraMapping);\n\nnode.status({\n    fill: 'green',\n    shape: 'dot',\n    text: `Loaded ${cameras.length} cameras`\n});\n\nmsg.payload = { loaded: cameras.length };\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 590,
        "y": 300,
        "wires": [["debug-config"]]
    },
    {
        "id": "debug-config",
        "type": "debug",
        "z": "sparking-metro-flow",
        "name": "Config Loaded",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "x": 800,
        "y": 300,
        "wires": []
    },
    {
        "id": "http-in-refresh",
        "type": "http in",
        "z": "sparking-metro-flow",
        "name": "Refresh Config",
        "url": "/refresh-config",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 140,
        "y": 360,
        "wires": [["fetch-camera-config-manual"]]
    },
    {
        "id": "fetch-camera-config-manual",
        "type": "http request",
        "z": "sparking-metro-flow",
        "name": "Fetch Cameras",
        "method": "GET",
        "ret": "obj",
        "paytoqs": "ignore",
        "url": "http://app:3000/api/cameras",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [
            {
                "keyType": "other",
                "keyValue": "x-api-key",
                "valueType": "env",
                "valueValue": "DETECTION_API_KEY"
            }
        ],
        "x": 380,
        "y": 360,
        "wires": [["store-camera-config-manual"]]
    },
    {
        "id": "store-camera-config-manual",
        "type": "function",
        "z": "sparking-metro-flow",
        "name": "Store & Respond",
        "func": "// Store camera configuration in flow context\nconst cameras = msg.payload;\n\nif (!Array.isArray(cameras)) {\n    msg.payload = { error: 'Invalid camera response' };\n    msg.statusCode = 500;\n    return msg;\n}\n\n// Build camera mapping and slot configurations\nconst cameraMapping = {};\n\ncameras.forEach((camera, index) => {\n    cameraMapping[String(index + 1)] = camera.id;\n    \n    if (camera.slots && camera.slots.length > 0) {\n        const slotConfig = camera.slots.map(slot => ({\n            id: slot.id,\n            detectionBounds: slot.detectionBounds || {\n                x: 0,\n                y: 0,\n                width: 1,\n                height: 1\n            }\n        }));\n        flow.set(`slots_${camera.id}`, slotConfig);\n    }\n});\n\nflow.set('cameraMapping', cameraMapping);\n\nmsg.payload = {\n    success: true,\n    camerasLoaded: cameras.length\n};\nmsg.statusCode = 200;\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 590,
        "y": 360,
        "wires": [["http-response"]]
    },
    {
        "id": "http-response",
        "type": "http response",
        "z": "sparking-metro-flow",
        "name": "Response",
        "statusCode": "",
        "headers": {},
        "x": 780,
        "y": 360,
        "wires": []
    }
]
